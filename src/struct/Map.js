/**
 * @class Ext.Map
 * @alternateClassName Ext.Set
 * @extends Ext.Class
 * @implements Ext.iter.Interface
 * @mixins Ext.iter.Summable
 * @mixins Ext.iter.Filterable
 *
 * Implements a hash map.
 */
Ext.define('Ext.Map', {

    implement: 'Ext.iter.Interface',

    alternateClassName: 'Ext.Set',

    uses: {
        summable: 'Ext.iter.Summable',
        filterable: 'Ext.iter.Filterable'
    },

    /**
     * Internal data storage
     */
    map: {},

    /**
     * Size of the map
     */
    size: 0,

    /**
     * @property {String} dataPropertyName
     * Name of the data property on the local iterable class implementation
     * @readonly
     */
    dataPropertyName: 'map',

    /**
     * @cfg {Function} [keyFn=autogenerated] Key generating function
     */
    keyFn: function() {
        return Ext.id('map');
    },

    /**
     * Constructor for the map
     * @return void
     */
    constructor: function() {

        this.addEvents(

            /**
             * @event beforeadd
             * This event gets fired before an item gets added to the map
             * @param {Ext.Map} this
             * @param {Mixed} key
             * @param {Mixed} item
             */
            'beforeadd',

            /**
             * @event add
             * This event gets fired when an item gets added to the map
             * @param {Ext.Map} this
             * @param {Mixed} key
             * @param {Mixed} item
             */
            'add',

            /**
             * @event beforeremove
             * This event gets fired before an item gets removed from the map
             * @param {Ext.Map} this
             * @param {Mixed} key
             * @param {Mixed} item
             */
            'beforeremove',

            /**
             * @event remove
             * This event gets fired when an item gets removed from the map
             * @param {Ext.Map} this
             * @param {Mixed} key
             * @param {Mixed} item
             */
            'remove',

            /**
             * @event beforereplace
             * This event gets fired before an item gets replaced in the map
             * @param {Ext.Map} this
             * @param {Mixed} key
             * @param {Mixed} item
             * @param {Mixed} oldItem
             */
            'beforereplace',

            /**
             * @event replace
             * This event gets fired when an item gets replaced in the map
             * @param {Ext.Map} this
             * @param {Mixed} key
             * @param {Mixed} item
             * @param {Mixed} oldItem
             */
            'replace',

            /**
             * @event beforeclear
             * This event gets fired before the map has been cleared
             * @param {Ext.Map} this
             */
            'beforeclear',

            /**
             * @event clear
             * This event gets fired when the map has been cleared
             * @param {Ext.Map} this
             */
            'clear',

            /**
             * @event beforetranspose
             * This event gets fired before the map get's transposed
             * @param {Ext.Map} this
             */
            'beforetranspose',

            /**
             * @event transpose
             * This event gets fired when the map has been transposed
             * @param {Ext.Map} this
             * @param {Ext.Map} transposedMap
             */
            'transpose'
        );

        this.callParent(arguments);

        // Init mixins
        this.initFilterable();

        // Clear map silently
        this.clear(true);
    },

    /**
     * Adds a whole object with all items to the map
     * @param {Object} object Object of data
     * @param {Boolean} silent (optional) If silent, no event will be fired
     * @return {Ext.Map}
     */
    addAll: function(object, silent) {

        var me = this;

        for (var propName in object) {
            me.add(propName, object[propName], silent);
        }
        return this;
    },

    /**
     * Builds an item out of key and value information
     * @param {String|Object} key Key
     * @param {Mixed} value Value
     * @return {Object}
     */
    buildItem: function(key, value) {

        if (!value) {
            value = key;
            key = this.keyFn()
        }
        return {
            key: key,
            value: value
        }
    },

    /**
     * Adds an item to the map
     *
     * @param {Mixed} key Key or item object (key auto-generated then)
     * @param {Mixed} item (optional) Item can be first argument too
     * @param {Boolean} silent (optional) If silent, no event will be fired
     * @return {Ext.Map}
     */
    add: function(key, item, silent) {

        var item = this.buildItem(key, item);

        if (!silent) {
            this.fireEvent('beforeadd', this, item.key, item.value);
        }
        this.size++;
        this.map[item.key] = item.value;

        if (!silent) {
            this.fireEvent('add', this, item.key, item.value);
        }
        return this;
    },

    /**
     * Removes an item from the map by key identifier
     * @param {Mixed} key Key identifier
     * @param {Boolean} silent (optional) If silent, no event will be fired
     * @return {Ext.Map}
     */
    removeAtKey: function(key, silent) {

        if (!silent) {
            this.fireEvent('beforeremove', this, key, this.map[key]);
        }
        this.size--;
        delete this.map[key];

        if (!silent) {
            this.fireEvent('remove', this, key, this.map[key]);
        }
        return this;
    },

    /**
     * Replaces a key of the map
     * @param {Mixed} key Key identifier
     * @param {Mixed} item Item value
     * @param {Boolean} silent (optional) If silent, no event will be fired
     * @return {Ext.Map}
     */
    replace: function(key, item, silent) {

        if (!silent) {
            this.fireEvent('beforereplace', this, key, item, this.map[key]);
        }
        this.map[key] = item;

        if (!silent) {
            this.fireEvent('replace', this, key, item, this.map[key]);
        }
        return this;
    },

    /**
     * Clears the whole map by reassigning the map with an empty Object
     * @param {Boolean} silent (optional) If silent, no event will be fired
     * @return {Ext.Map}
     */
    clear: function(silent) {

        if (!silent) {
            this.fireEvent('beforeclear', this);
        }
        this.map = {};
        this.size = 0;

        if (!silent) {
            this.fireEvent('clear', this);
        }
        return this;
    },

    /**
     * Returns the map size
     * @return {Number}
     */
    getCount: function() {
        return this.size;
    },

    /**
     * Returns an item for a given key
     * @param {Mixed} key Key identifier
     * @return {Mixed}
     */
    get: function(key) {
        return this.map[key];
    },

    /**
     * Calls the given function for each property in the map
     * @param {Function} fn Function to call per property
     * <div class="mdetail-params"><ul>
     * <li><b>key</b> : String<p class="sub-desc">The key (property name)</p></li>
     * <li><b>value</b> : Mixed<p class="sub-desc">The value (value data)</p></li>
     * <li><b>object</b> : Object<p class="sub-desc">The map's data object</p></li>
     * </ul></div>
     * @param {Object} scope (optional) Callback call scope
     * @return {Ext.Map}
     */
    each: function(fn, scope) {
        Ext.Object.each(this.map, fn, scope);
        return this;
    },

    /**
     * Clones this map instance. Please note that listeners aren't cloned.
     * @return {Ext.Map}
     */
    clone: function() {

        var cloneData = Ext.clone(this.map),
            cloneMap = new Ext.Map();

        cloneMap.map = cloneData;
        cloneMap.size = this.size;
        cloneMap.keyFn = this.keyFn;

        return cloneMap;
    },

    /**
     * Returns the values of this map as Array
     * @return {Array}
     */
    getValues: function() {

        var values = [];
        this.each(function(key, value) {
           values.push(value);
        });
        return values;
    },

    /**
     * Returns the keys of this map as Array
     * @return {Array}
     */
    getKeys: function() {

        var keys = [];
        this.each(function(key) {
           keys.push(key);
        });
        return keys;
    },

    /**
     * Returns true if the given item is a member of the map
     * @param {Mixed} item Item to check for
     * @return {Boolean}
     */
    contains: function(item) {

        var contains = false;
        this.each(function(key, value) {
           if (value === item) {
               contains = true;
           }
        });
        return contains;
    },

    /**
     * Returns true if the given key is a member of the map
     * @param {Mixed} key Key to check for
     * @return {Boolean}
     */
    containsKey: function(key) {

        var containsKey = false;
        this.each(function(itemKey) {
           if (key === itemKey) {
               containsKey = true;
           }
        });
        return containsKey;
    },

    /**
     * Removes an item from the map
     * @param {Mixed}Â item Item to remove
     * @param {Boolean} silent (optional) If silent, no event will be fired
     * @return {Ext.Map}
     */
    remove: function(item, silent) {

        var me = this;
        this.each(function(key, value) {
           if (item === value) {
               me.removeAtKey(key, silent);
           }
        });
        return this;
    },

    /**
     * Returns the internal map
     * @protected
     * @return {Object}
     */
    getMap: function() {
        return this.map;
    },

    /**
     * Returns the count of a map's keys
     * @return {Number}
     */
    count: function() {
        return Ext.Object.count(this.map);
    },

    /**
     * Returns true if the map is empty
     * @return {Boolean}
     */
    isEmpty: function() {
        return (this.count() > 0) ? true : false
    },

    /**
     * Returns an Array out of the Map
     * @param {Boolean} [flatten=false] (optional) Indicator if a flat array without keys should be returned
     * @return {Array}
     */
    toArray: function(flatten) {
        return Ext.toArray(this.map, flatten);
    },

    /**
     * Returns the map's data object
     * @return {Object}
     */
    toObject: function() {
        return this.map;
    },

    /**
     * Returns a map (clone) in which all the keys and values are interchanged.
     * Note that duplicate keys are not allowed in maps. So if you transpose a map
     * and duplicate values occur, the last value wins in it's new role as key.
     * @param {Boolean} silent (optional) If silent, no event will be fired
     * @return {Ext.Map}
     */
    transpose: function(silent) {

        if (!silent) {
            this.fireEvent('beforetranspose', this);
        }

        var cloneMap = this.clone(),
            cloneMapData = cloneMap.map;
            transposedMap = {};

        // Transpose key and value
        Ext.each(cloneMapData, function(value, key) {
            transposedMap[value] = key;
        });

        cloneMap.map = transposedMap;
        cloneMap.size = Ext.Object.count(cloneMap.map);

        if (!silent) {
            this.fireEvent('transpose', this, cloneMap);
        }
        return cloneMap;
    },

    /**
     * Transforms the map into an Ext.Collection instance
     * @return {Ext.Collection}
     */
    toCollection: function() {

        return Ext.collection(
            Ext.Object.toArray(this.map)
        );
    }
});

/**
 * Creates an instance of Ext.Map.
 * @param {Object} object (optional) Initial map data to be added
 * @param {Boolean} silent (optional) If silent, no event will be fired
 * @member Ext
 * @method map
 */
Ext.map = function(object, silent) {

    var m = Ext.create('Ext.Map');

    // Set map if given
    if (object) {
        m.addAll(object, silent);
    }
    return m;
};